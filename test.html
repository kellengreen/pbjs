<!DOCTYPE html>
<html>
<head>
    <title>Pb.js</title>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<style>
	body {
		color: hsl(0, 0%, 70%);
		background-color: hsl(0, 0%, 15%);
	}
</style>
<body>

	<div
		pb-is="scroll-on-hover"
		pb-state=""
		two-way-bind="obj.path"
		one-way-bind="obj.path"
		test='.foo.5\.0.bar.'
	></div>


<script>

class A {

	static register(id) {
		this.id = this === A ? id.toString() : `${Object.getPrototypeOf(this).id}.${id}`;
	}
}
A.register('a');

class B extends A {}
B.register('b');

class C extends B {}
C.register('c');


const c = new C();

function split(str) {
	const matches = [];
	const last = str.length - 1;
	for (let current = 0, prev = 0; current < str.length; current++) {

		// period found
		if (str.substr(current, 1) === '.') {

			// period at the beginning
			if (current === 0) {
				matches.push('');
				prev++;
			}

			//
			else if (str.substr(current - 1, 1) !== '\\') {
				matches.push(str.slice(prev, current));

				// last
				if (current === last) {
					matches.push('');
				}

				prev = current + 1;
			}
		}

		// reached end of string
		else if (current === last) {
			matches.push(str.slice(prev));
		}
	}
	return matches;
}



// function childStorage() {

// }

// function scope(obj) {
// 	/**
// 	 *
// 	 */
// 	obj.listeners = new Map();

// 	obj.addListener(path, callback) {
// 		/**
// 		 *
// 		 */
// 	}

// 	obj.removeListener(path, callback) {
// 		/**
// 		 *
// 		 */
// 	}

// 	obj.getByPath(path) {
// 		/**
// 		 *
// 		 */
// 	}

// 	obj.setByPath(path, value) {
// 		/**
// 		 *
// 		 */
// 	}

// 	const proxy = new Proxy(obj, {
// 	    get: function(target, path) {
// 	    	/**
// 	    	 *
// 	    	 */
// 	        console.log(`get: ${path}`);
// 	    	const names = path.split('.');
// 	    	for (let i = 0; i < names.length; i++) {

// 	    	}
// 	        return target[path];
// 	    },
// 	    set: set(target, path, value) {
// 	    	/**
// 	    	 *
// 	    	 */
// 	        console.log(`set: ${path}`);
// 	        target[path] = value;
// 	        return true;
// 		}
// 	});
// }

(function() {

	class DomManager {
		/**
		 *
		 */
		constructor(elem) {
			/**
			 *
			 */
			this.idAttr = 'pb-is';
			this.ids = new Set();

			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes') {
						this.attrChanged(mutation.target, mutation.attributeName);
					} else if (mutation.type === 'childList') {
						this.elemsAdded(mutation.addedNodes);
						this.elemsRemoved(mutation.removedNodes);
					}
				});
			});

			observer.observe(document.body, {
				childList: true, 	// child elements
				subtree: true,		// childrens descendants
				attributes: true	// attribute changes
			});
		}

		attrChanged(elem, name) {
			/**
		 	 * Element attribute has changed.
		 	 */
		 	if (elem.$pb) {
		 		const fn = elem.$pb.attrs.get(name);
		 		if (fn) {
		 			const value = elem.getAttribute(name);
		 			fn(value);
		 		}
		 	}
		}

		elemsAdded(elems) {
			/**
			 * Elements added.
		 	 */
			for (let i = 0, elem; elem = elems[i]; i++) {
				if (elem instanceof HTMLElement) {
					const id = elem.getAttribute(this.idAttr);
		 			if (this.ids.has(id)) {
						this.promote(id, elem);
		 			}
	 			}
			}
		}

		elemsRemoved(elems) {
			/**
		 	 * 	Elements removed, delete the reference to pbElement.
		 	 */
			for (let i = 0, elem; elem = elems[i]; i++) {
				const pb = elem.$pb;
				if (pb) {
					pb.demote();
					delete elem.$pb;
				}
			}
		}

		promote(id, elem) {
			/**
		 	 * Promote element to PbElement.
		 	 */
		 	const PbElem = this.id.get(id);
		 	elem.$pb = new PbElem(elem);
		}

		register(id) {
			/**
		 	 * Register new id, then find elems already added to the dom and promote.
		 	 */
			if (this.ids.has(id)) {
				throw `"${id}" has already been registered`;
			} else {
				const elems = document.querySelectorAll(`[${this.idAttr}="${id}"]`);
				for (let i = 0, elem; elem = elems[i]; i++) {
					this.promote(id, elem);
				}
			}
		}
	}

	const domManager = new DomManager();

	class PbElement {
		/**
		 * Base extendable element.
		 */
		constructor(elem) {
			/**
			 *
			 */
			this.elem = elem;
			this.state = null;
			this.attrs = new Map([
				['pb-state', this.stateChange]
			]);

			this.listeners = {
				'*': [
					[this.elem, 'click', (evt) => {
						//...
					}]
				],
				'open': [
					[document.body, 'click', (evt) => {

					}]
				]
			};
		}

		promote() {
			/**
			 *
			 */

			// initalize attributes
			for (let pair in this.attrs.values()) {
				const [name, fn] = pair;
				const value = elem.getAttribute(name);
				fn(value);
			}

			// initialize stateless listeners
			for (let [obj, type, callback, options] of this.listeners['*']) {
				obj.addEventListener(type, callback, options);
			}
		}

		demote() {
			/**
			 *
			 */
			// remove stateless listeners
			for (let [obj, type, callback, options] of this.listeners['*']) {
				obj.removeEventListener(type, callback, options);
			}
		}

		stateChange(value) {
			/**
			 *
			 */
			let listeners;

			// remove old listeners
			listeners = this.listeners[this.state];
			if (listeners) {
				for (let [obj, type, callback, options] of listeners) {
					obj.removeEventListener(type, callback, options);
				}
			}

			this.state = value;

			// add new listeners
			listeners = this.listeners[this.state];
			for (let [obj, type, callback, options] of listeners) {
				obj.addEventListener(type, callback, options);
			}

		}

		// getParentScope() {
		// 	/**
		// 	 *
		// 	 */
		// 	let elem = this.elem;
		// 	while (elem = elem.parentElement) {
		// 		if (elem.$pb instanceof ProducerElement) {
		// 			return elem;
		// 		}
		// 	}
		// 	return null;
		// }

		static register(id) {
			/**
			 *
			 */

		}
	}

	class ProducerElement extends PbElement {
			constructor(element) {
				// super(element);

				this.scope = this.getParentScope();

				this.listeners['*'].push(
					[this.elem, 'click', (evt) => {
						//...
					}]
				);

				this.listeners['open'] = [
					[this.elem, 'click', (evt) => {
						//...
					}]
				];

				// this.attrs.add('pb-scope', (name, value) => {

				// });

		}
	}

	class RepeatElement extends ProducerElement {
		constructor(element) {
			super(element);
		}
	}

	class ConsumerElement extends PbElement {
		constructor(element) {
			super(element);
		}

		getScope() {
			let elem = this.elem;
			while (elem = elem.parentElement) {
				if (elem.$pb instanceof _.ScopeElement) {
					return elem;
				}
			}
			return null;
		}
	}

	window.pb = {};
})();
</script>
</body>
</html>



